using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Enhanced.NRedisStack.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class SchemaGenerator : IIncrementalGenerator
{
    private const string AttributeTypeName = "GeneratedSchemaAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter abstract methods annotated with the [SchemaOf] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, _) => node is MethodDeclarationSyntax {AttributeLists.Count: > 0, Modifiers: {Count: > 0}},
                (ctx, _) => GetMethodDeclarationForSourceGen(ctx))
            .Where(t => t.matches)
            .Select((t, _) => t.method);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private static (MethodDeclarationSyntax method, bool matches) GetMethodDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var methodDeclarationSyntax = (MethodDeclarationSyntax) context.Node;

        foreach (AttributeListSyntax attributeListSyntax in methodDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue;

            if (attributeSymbol.ContainingType.Name != AttributeTypeName)
                continue;

            return (methodDeclarationSyntax, true);
        }

        return (methodDeclarationSyntax, false);
    }

    private void GenerateCode(
        SourceProductionContext context, Compilation compilation,
        ImmutableArray<MethodDeclarationSyntax> methodDeclarations)
    {
        foreach (var methodDeclaration in methodDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(methodDeclaration.SyntaxTree);
            var declaredSymbol = semanticModel.GetDeclaredSymbol(methodDeclaration);

            if (declaredSymbol is not IMethodSymbol methodSymbol)
            {
                // Log error
                continue;
            }

            if (!methodSymbol.IsPartialDefinition)
            {
                // Log error
                continue;
            }

            if (methodSymbol.Parameters.Length > 0)
            {
                // Log error
                continue;
            }

            if (methodSymbol.TypeParameters.Length > 0)
            {
                // Log error
                continue;
            }

            var attributeValue = methodSymbol
                .GetAttributes().First(data => data.AttributeClass?.Name == AttributeTypeName)
                .ConstructorArguments.First();
            
            if (attributeValue is not {Kind: TypedConstantKind.Type})
            {
                // Log error
                continue;
            }
            
            if (attributeValue.Value is not INamedTypeSymbol modelSymbol)
            {
                // Log error
                continue;
            }
            
            var sourceText = GenerateCore(methodSymbol, modelSymbol);
            var sourceFileName = $"{methodSymbol.ContainingType.Name}.{methodSymbol.Name}.g.cs";

            context.AddSource(sourceFileName, sourceText);
        }

        /*// Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in methodDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text;

            // Go through all class members with a particular type (property) to generate method lines.
            var methodBody = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Select(p =>
                    $@"        yield return $""{p.Name}:{{this.{p.Name}}}"";"); // e.g. yield return $"Id:{this.Id}";

            // Build up the source code
            var code = $@"// <auto-generated/>

using System;
using System.Collections.Generic;

namespace {namespaceName};

partial class {className}
{{
    public IEnumerable<string> Report()
    {{
{string.Join("\n", methodBody)}
    }}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }*/
    }

    private static SourceText GenerateCore(IMethodSymbol methodSymbol, INamedTypeSymbol modelSymbol)
    {
        using var writer = new SchemaWriter();
        
        using (writer.DeclarePartialClass(methodSymbol.ContainingType))
        using (writer.DeclarePartialMethod(methodSymbol))
        {
            writer.WriteLine("Schema schema = new Schema();");
            modelSymbol.Accept(new SchemaMemberVisitor("schema", writer));
            writer.WriteLine("return schema;");
        }

        return writer.ToSourceText();
    }
}